<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Haroun Maghraoui</title><link>https://haroun.me/posts/</link><description>Recent content on Haroun Maghraoui</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Sun, 20 Mar 2022 20:30:00 +0100</lastBuildDate><atom:link href="https://haroun.me/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Memory Forensics: A Fun Hands on Introduction</title><link>https://haroun.me/posts/memory-forensics-a-fun-hands-on-introduction/</link><pubDate>Sun, 20 Mar 2022 20:30:00 +0100</pubDate><guid>https://haroun.me/posts/memory-forensics-a-fun-hands-on-introduction/</guid><description>Last weekend, CyberTrace held its first large-scaled event, the Cyber Summit. It held a multitude of conferences and workshops alongside an on-site CTF at night. And I had the honor to be one of the trainers that animated one of the aforementioned workshops. So, as many attendees asked me to, I&amp;rsquo;m writing this walkthrough to collect and preserve the knowledge shared through the workshop. Plus, I&amp;rsquo;m hoping this becomes something of use for people wanting to dive in the forensics field as I didn&amp;rsquo;t find as many well-maintained ressources as i wished while preparing it.</description><content type="html"><![CDATA[<p>Last weekend, <strong>CyberTrace</strong> held its first large-scaled event, the Cyber Summit. It held a multitude of conferences and workshops alongside an on-site CTF at night. And I had the honor to be one of the trainers that animated one of the aforementioned workshops. So, as many attendees asked me to, I&rsquo;m writing this walkthrough to collect and preserve the knowledge shared through the workshop. Plus, I&rsquo;m hoping this becomes something of use for people wanting to dive in the forensics field as I didn&rsquo;t find as many well-maintained ressources as i wished while
preparing it.</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*n3sEc6aukj0e0Z93t_stGQ.png" alt="CyberTrace"></p>
<p>The workshop&rsquo;s topic was memory forensics, and the concerned audience was total beginners that had no clue what does forensics even mean. Considering the short allocated time, which is 2 hours, I chose to challenge myself preparing some quitely dense content and trying to deliver it efficiently. My goal was to introduce the audience to the field without being too superficial. Plus, I was really tired of the classiscal method that the majority of forensics introductions would approach, that is just loosely defining the field and then bombing the audience with volatility&rsquo;s plugins and what they do. So, considering all these factors, I decided that my workshop should be nothing like that and follow a kind of exotic approach.</p>
<h3 id="workshops-scenario-andtools">Workshop&rsquo;s scenario and tools:</h3>
<p>I made the workshop as to be a real life simulation that goes like this:<br>
A non-IT friend of yours notices some weird behaviour on his computer. Random files would appear and disappear, sudden screen blackouts, indicator leds going on and off. So, he reachs out to you, the Cybersecurity saviour, to diagnose his problem. We instruct him on how to take a memory dump of his computer and send it to us, and the rest of the procedure is what we&rsquo;re gonna do during the workshop.</p>
<p>Before we start, let&rsquo;s talk a little about the tools we&rsquo;re gonna need. In fact, it&rsquo;s only one tool called Volatility. It could be considered as the de-facto framework for memory analysis. It&rsquo;s a modular open source tool that contains a multitude of plugins, each one analyzes certainaspects of a dump and provides an output that helps the analyst create an outlook on what is happening. Volatility has two major versions, 2 and 3. Volatility 2 is the well developed older release written in python2. Volatility 3 is the new player in the scene, a complete rewrite of its predecessor written in python3. Although a little underdeveloped as it is somewhat new, it&rsquo;s faster than it&rsquo;s big brother, and we&rsquo;re gonna rely on it throughout the workshop.</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*KfO3uxglMpLOYcyFJ4iDiA.png" alt="Volatility&amp;rsquo;s logo"></p>
<h3 id="enough-talking-lets-get-our-handsdirty">Enough talking, let&rsquo;s get our hands dirty:</h3>
<p>First thing we must do is to try and get some initial info on the machine, this could be done using <em>windows.info</em> (We already know our friend uses windows). This plugin contain some intuitive but necessary info such as the OS version, architecture type and the system time when the dump was made.</p>

    <img src="info.png"  alt="windows.info"  class="center"  style="border-radius: 8px;"  />


<p>We could see that our friend has windows 10. Starting with volatility 3 was a good decision, because if we were to run volatility 2&rsquo;s <em>imageinfo</em> on a windows 10 dump, it would have taken an eternity.</p>
<p>Having a black box dump, a nice starting point would be checking what processes were runnig on the computer, this could be done using <em>windows.pslist</em> plugin (For now, as sometimes a more thorough scan would be needed using <em>windows.psscan</em>).</p>
<p>What i truly advise when using volatility is to save the output of each plugin in a file as it&rsquo;s sometimes very long and verbose which could be hard to manipulate on the terminal.<br>
We&rsquo;re gonna need the output of <em>windows.pslist</em> throughout the whole workshop, but for now, let&rsquo;s analyze it and check for interesting
processes.</p>
<pre tabindex="0"><code>python3 vol.py -f ./workshopMemoryDump.raw windows.pslist | tee ./Workshop/pslist
</code></pre>
    <img src="pslistChrome.png"  alt="chrome.exe in windows.pslist&#39;s output"  class="center"  style="border-radius: 8px;"  />


<p>We could notice <strong>chrome.exe</strong> running, which is pretty interesting knowing that we could extract its history searching for some leads. The problem is that, as we stated above, volatility 3 is still in its early days and lacking many plugins, namely the volatility 2&rsquo;s community plugin <em>chromehistory</em>. We could of course extract history the hard way (By dumping chrome&rsquo;s database), but, for the sake of simplicity, I&rsquo;m going to fallback to volatility 2.</p>

    <img src="chromehistory.png"  alt="Volatility2&#39;s chromehistory output"  class="center"  style="border-radius: 8px;"  />


<p>Okay, pretty interesting, from what we&rsquo;ve seen so long, we could try to form an initial image of what our friend was doing. I think he wanted to crack his GTA 5 installation, so he went through torrent sites to find a valid crack. This could be reinforced by remarking the
<strong>qbittorrent.exe</strong> process running.</p>
<p>I think it&rsquo;s time to have a look at what we could recover from our friend&rsquo;s files. This could be done using <em>windows.filescan</em> plugin. An important note worth remembering here is that <em>windows.filescan</em> is not gonna show us a list of all the files that exist on the system, rather it&rsquo;s going to list files recently or currently loaded in memory.</p>
<pre tabindex="0"><code>python3 vol.py -f ./workshopMemoryDump.raw windows.filescan| tee ./Workshop/filescan
</code></pre><p>Since the output of this plugin is really really really long (as it&rsquo;s going to list all of the operating systems files and dlls alongside other entries). We need to look for certain patterns. What I prefer doing is grepping common user directories such as <em>Desktop</em>, <em>Documents</em>
and <em>Downloads</em>.</p>

    <img src="grepDownloads.png"  alt="Grepping User directories in windows.filescan&#39;s output"  class="center"  style="border-radius: 8px;"  />


<p>One remarkable entry in the output is the <strong>GTA V Crack</strong> directory, containing <strong>patch.exe</strong> and <strong>README.txt</strong>. As we all know, READMEs usually contain instructions as to how to use a software, so let&rsquo;s take a look at <strong>README.txt</strong> by dumping it. All we need to do is to execute the <em>windows.dumpfiles</em> plugin, which is used, as its name states, to dump files from memory. An important fact about dealing with files in relation to memory is that finding them in <em>windows.filescan</em> doesn&rsquo;t necessarily mean it&rsquo;s always possible to dump them. This is a consequence to the volatility of the memory, knowing that a file has existed at a certain time in the memory doesn&rsquo;t mean is still does exist. In other words, not all files that shows up in the output of <em>windows.filescan</em> could be dumped.</p>

    <img src="dumpfiles.png"  alt="Trying to dump README.txt through windows.dumpfiles"  class="center"  style="border-radius: 8px;"  />


<p>We could see that <strong>README.txt</strong> couldn&rsquo;t be dumped, and this is something I struggled with when preparing the lab, due to the very small size of the text file. But, we musn&rsquo;t get desperate, because there&rsquo;s a solution. The NTFS filesystem, used in windows since 1993 uses a data structure known as the Master File Table to index all its files. Each record in the MFT includes some metadata about the file and a pointer to its location on the disk, <em>usually</em>. This is not the case for very small files, which NTFS stores alongside their metadata in their MFT records, such files are called <em>resident files</em>. Here, Volatility3 prematurity arises again, as it only contains <em>winows.mftscan</em>, which is aged a mere 2 months and is incapable of extracting info from the MFT, so we&rsquo;re going to use volatility 2&rsquo;s <em>mftparser</em>.</p>
<pre tabindex="0"><code>python2 vol.py -f ./workshopMemoryDump.raw mftparser | tee ./Workshop/mftparser
</code></pre>
    <img src="readmemft.png"  alt="README.txt MFT record"  class="center"  style="border-radius: 8px;"  />


<p>And as we predicted, <strong>README.txt</strong>&rsquo;s data is there in its MFT record, and it is instructing the user to run <strong>patch.exe</strong>. Going back to <em>windows.pslist</em>&rsquo;s output, we could see that <strong>patch.exe</strong> is in fact running.</p>

    <img src="patch.png"  alt="patch.exe in windows.pslist"  class="center"  style="border-radius: 8px;"  />


<p>So, let&rsquo;s take a little pause to recapitulate our findings. What we found out to this point is this: Our friend, whose computer had weird behaviour, was searching for a crack for GTA 5 on torrent sites. He apparently downloaded a certain torrent and ran the shady executable it contains, as he was instructed by the README. I think that the culprit is becoming crystal clear, <strong>patch.exe</strong> probably contains a malware. But, let&rsquo;s not rush into a conclusion this fast. In fact, as of this point, many analysis possibilities show up. But, I&rsquo;m going to choose an easy path, for the sake of simplicity. Knowing that the weird behaviour on our friend&rsquo;s computer doesn&rsquo;t have a clear pattern, we could safely assume that if a malware exists, it&rsquo;s controlled by an attacker. That means that it needs to connect to a remote address. So, let&rsquo;s check remote connections made by processes using *windows.netstat *.</p>
<pre tabindex="0"><code>python3 vol.py -f ./workshopMemoryDump.raw windows.netstat| tee ./Workshop/netstat
</code></pre>
    <img src="patchNetstat.png"  alt="patch.exe connecting to the remote port 4444"  class="center"  style="border-radius: 8px;"  />


<p>As we predicted, <strong>patch.exe</strong> is connecting to a remote address. The remarkable thing about this connection is the remote port which is <strong>4444</strong>. For those who don&rsquo;t know, <strong>4444</strong> is the default listening port for <em>Metasploit&rsquo;s Meterpreter</em>. So it&rsquo;s somewhat safe to assume by a high probability that the computer is controlled by a <em>meterpreter</em>. But a remote port alone isn&rsquo;t enough to strictly confirm. That&rsquo;s why we&rsquo;re continuing our analysis by executing <em>windows.malfind</em>, which tries to locate malicious code instructions and dlls inside the memory. For the sake of simplicity, here&rsquo;s what I&rsquo;m going to do: I&rsquo;m going to run <em>windows.malfind</em> with the &mdash; dump flag which dumps the suspicious memory areas and then pass it through <em>clamav</em> to test it.</p>
<pre tabindex="0"><code>python3 vol.py -f ./workshopMemoryDump.raw windows.malfind | tee ./Workshop/malfind
</code></pre>
    <img src="clamscan.png"  alt="clamscan result"  class="center"  style="border-radius: 8px;"  />


<p>As we could see, our suspicion turned out to be true, a <em>meterpreter</em> was detected by <em>clamav</em>.</p>
<h2 id="conclusion">Conclusion:</h2>
<p>To conclude our analysis , let&rsquo;s have a little summary of our findings. Our friend, who have a weirdly-behaving computer, searched for a GTA 5 crack and installed a sketchy executable through some torrent then ran it. This executable contained a <em>meterepreter</em> which infected the computer and allowed the attacker to control it and execute whatever malicious command he wished to.</p>
<p><strong>Coming to this conclusion, I mark the end of this workshop. I hope you find it useful, and I hope that it&rsquo;s clear enough for you to understand as I tried to engage in some pretty advanced concepts without losing the beginner-friendly aspect. I&rsquo;d be so happy hearing your feedback, remarks or criticism. So, don&rsquo;t hesitate to contact me.</strong></p>
<hr>
<h3 id="remarks">Remarks:</h3>
<ul>
<li>For reference, here&rsquo;s how a volatility command usually looks like:</li>
</ul>
<pre tabindex="0"><code>python vol.py -f &lt; Memory dump&#39;s path &gt; &lt; plugin name &gt; &lt; plugin arguments&gt;
</code></pre><ul>
<li>Why a Windows 10 dump ? Because I&rsquo;ve had enough of Windows 7 tutorials. Yeah it&rsquo;s more convenient to use but it&rsquo;s way too outdated. People don&rsquo;t use it anymore. So, they can&rsquo;t relate to it. Why Volatility3 ? for the same reason, enough of volatility2. Volatility3 is faster, more compatible with Windows 10, and is starting to catch on Volatility2. Plus, if anyone wants to learn Volatility2 and Windows7 , the internet is full of such tutorials, they won&rsquo;t need to attend a workshop and waste their time.</li>
<li>You could notice that the workshop&rsquo;s flow was kind of linear. That&rsquo;s was made on purpose to keep the attendee&rsquo;s attention. But beware, real life isn&rsquo;t even nearly like this. That&rsquo;s why you should always be cautious not to fall in a rabbit hole.</li>
<li>I advise you to reproduce the steps stated above on your own to better grasp the discussed concepts.</li>
<li>Bonus tips: you could dump a process&rsquo;s memory space using windows.memmap, or its binary using windows.dumpfiles.</li>
</ul>
<hr>
<h3 id="ressources">Ressources:</h3>
<ul>
<li><a href="https://mega.nz/file/AvYHHbqa#tfPm4ZhkS7IUqat7ab__9SKVRtw96BB6Q2R6JqCwm2Q">The memory dump used.</a></li>
<li><a href="https://github.com/volatilityfoundation/volatility3">Volatility 3&rsquo;s repo.</a></li>
<li><a href="https://github.com/volatilityfoundation/volatility">Volatility 2&rsquo;s repo.</a></li>
</ul>
]]></content></item><item><title>Blockchain: An Easy to Digest Detailed Explanation</title><link>https://haroun.me/posts/blockchain-an-easy-to-digest-detailed-explanation/</link><pubDate>Sun, 20 Jun 2021 17:00:00 +0100</pubDate><guid>https://haroun.me/posts/blockchain-an-easy-to-digest-detailed-explanation/</guid><description>Who didn&amp;rsquo;t hear about Bitcoin and the fascinating surge that occured to its value ? And who didn&amp;rsquo;t encounter a post or an article talking about the magic of cryptocurrencies that could make you rich suddenly ? I imagine that everybody could relate to these questions. Unfortunately, this trend and hype is usually used by medias and blogs in order to gain views and reach, but rarely to discuss the technologies behind it.</description><content type="html"><![CDATA[<p>Who didn&rsquo;t hear about Bitcoin and the fascinating surge that occured to its value ? And who didn&rsquo;t encounter a post or an article talking about the magic of cryptocurrencies that could make you rich suddenly ? I imagine that everybody could relate to these questions. Unfortunately, this trend and hype is usually used by medias and blogs in order to gain views and reach, but rarely to discuss the technologies behind it. So today, I decided to talk to you about Blockchain (the underlying architecture of Bitcoin), its fundementals and how it revolutionized the currency market.</p>
<p>First of all, I think it&rsquo;s necessary to clarify some misconceptions. Blockchain isn&rsquo;t Bitcoin, and Bitcoin isn&rsquo;t Blockchain. In fact, it&rsquo;s true that Blockchain was created by <em>Satoshi Nakamoto</em> for the sole prurpose of inventing the Bitcoin. But, it could be used in way more applications other than cryptocurrencies. So, to make it clear since the beginning, I&rsquo;m going to talk about the Blockchain as a data structure and a network, in its broad definition, and not about its usage in cryptocurrencies. And I might be a little biased to the original Bitcoin Blockchain . Although, I am going to cover other variations in another post.</p>
<p><strong>So, to begin with, let&rsquo;s talk about what blockchain is ? and what are its main components ?</strong></p>
<p>Blockchain is a <em>decentralised, distributed</em> and usually public data structure and network. Its main goal is to be a <em>trustworthy ledger</em>, or generally speaking, a <em>trustworthy archive of information</em>, without needing a central authority to ensure this trust.</p>
<p>A Blockchain is formed of blocks. Each block is no more than a set of data that is structured according to strict rules, and is built on top of a previous block, starting from the initial <em>Genesis Block</em>. A block&rsquo;s header contains necessarily a <em>Merkle root</em>, the previous block&rsquo;s hash (except for the initial one of course) and a <em>nonce</em> in some cases (that we&rsquo;ll discuss later). A blocks&rsquo;s body contains the <em>Merkle Tree</em> associated with the forementioned <em>Merkle Root</em>. Before passing to the next question, let&rsquo;s first discuss what a <em>Merkle Tree</em> is.</p>
<p>To put it in simple terms, a <em>Merkle tree</em> is a full binary tree of hashes. <em>Merkle tree</em>&rsquo;s leaves are transactions/data included in the block. Each parent in the tree is a hash of his two siblings. So, if a single transaction is changed, even slightly, the <em>Merkle Root</em> will change drastically. This is useful when checking for the integrity of a block.</p>
<p><strong>So, now we know what a blockchain is, and how it is formed. But, who is responsible for creating and verifying the blockchain ?</strong><br>
In fact, the answer to this question is as famous as Bitcoin. The creation and verification of a Blockchain is the miners&rsquo; job. To better illustrate a miner&rsquo;s work, let&rsquo;s talk about the general process of block creation. First, a transaction/data is issued and broadcasted to the network. It will be then included in a transaction/data pool. Then, a miner will grab a bunch of transactions/data according to some criteria to form a new block. He creates the <em>Merkle Tree</em> out of those transactions/pieces of data and includes it in the block. He calculates he nonce if there is any. And when all of this is ready, he adds the block to the blockchain by appending the previous block&rsquo;s hash in the present hash&rsquo;s header.</p>
<p><strong>But, what if two miners submit their blocks at the same time ?</strong></p>
<p>Well, don&rsquo;t worry, blockchain is built ready for this problem. Both blocks will be accepted, but one of them will be later dismissed. In fact, a strict rule in blockchain is that the longest chain must be the main chain. In other words, when both blocks are added, future blocks will be built on either of these conflicting ones. The block on which a longer chain is built will be kept, while the other block and the chain that followed him will be deprecated and orphaned, their transactions/data will be sent back to a transactions/data pool.</p>
<p><strong>Here, a serious question arises, how are we sure that every miner will submit an honest trustworthy block ?</strong></p>
<p>This is where consensus kicks in. What&rsquo;s consensus ? it is any form of rules, procedures or protocols that leads to a major undebatable agreement. One of many ways to reach consensus in blockchains is the <em>Proof-Of-Work</em>. <em>Proof-Of-Work</em> is a cryptographic challenge that proves undoubtedly that a certain party has exerced some amount of work. As usual, to make things simple and clear, let&rsquo;s talk about how <em>Proof-Of-Work</em> is applied in the case of blockchain. Let&rsquo;s go back to block creation. When a block is created for a blockchain that requires <em>PoW</em>, the miner has to find a number called a <em>nonce</em> (mentioned above) that, when added to the block&rsquo;s header, results in a block hash that starts with a given number of zeros. But how does this ensures the honesty of the blockchain ? Okay, let&rsquo;s suppose a malicious miner has decided to append a dishonest block (where he tries to spend a coin he already spent for example). Since the rest of the miners will refuse to build on top of this block, an honest block will be appended on the same height, creating a conflict. To make sure his block will be accepted, the dishonest miner must race the rest of miners and create the longer chain on top of his dishonest block. That means his hashrate must surpass the hashrate of all the other miners combined. Put in simple terms, for a dishonest miner to append a dishonest block, he must own over half of the processing power of the blockchain. This is one way of reaching consensus and building an honest blckchain, but it isn&rsquo;t the only one. We&rsquo;ll discuss other methods in another post.</p>
<p><strong>The image is starting to get clear now. But, we must ask a very important question. Why would a miner bother sacrifice all this power and CPU time with no apparent benefice ?</strong></p>
<p>Well, because there is a benefice. The benefice is called an <em>incentive</em>. It is some kind of a reward that a miner gets when his block becomes a part of the blockchain. It could take many forms. In Bitcoin there is two forms. One way of getting rewarded is that a miner would append a special transaction on his block that states that he received a certain fixed amount of coins. In this way, if his block is appended, he would possess that amount of coins. The other way is by obtaining a tip from users on every transaction performed, called <em>transaction fees</em>. Like this, we would make sure that miners are motivated and satisfied.</p>
<p>This was a little guide on how blockchains work. I hope that you enjoyed your read and that you didn&rsquo;t get bored. Expect another post from me that talks about other variations that are slightly different from the one discussed above. And if you have the slightest comment to add, don&rsquo;t hesitate to contact me.</p>
<hr>
<p><em>References:</em></p>
<ul>
<li><a href="https://bitcoin.org/bitcoin.pdf">Bitcoin&rsquo;s original white paper.</a></li>
<li><a href="https://selfkey.org/what-is-a-merkle-tree-and-how-does-it-affect-blockchain-technology/">What is a Merkle Tree and How Does it Affect Blockchain Technology?</a></li>
<li><a href="https://www.youtube.com/watch?v=bBC-nXj3Ng4">But how does bitcoin actually work?</a></li>
</ul>
]]></content></item></channel></rss>