<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Haroun Maghraoui</title><link>https://haroun.me/posts/</link><description>Recent content on Haroun Maghraoui</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Sun, 12 Jun 2022 13:31:43 +0100</lastBuildDate><atom:link href="https://haroun.me/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Solving My First Keygenme</title><link>https://haroun.me/posts/solving-my-first-keygenme/</link><pubDate>Sun, 12 Jun 2022 13:31:43 +0100</pubDate><guid>https://haroun.me/posts/solving-my-first-keygenme/</guid><description>I&amp;rsquo;ve been wanting to dive in the reverse engineering field for a long time. But, everytime I start learning it I get frustrated and stop. I think this is a feeling that every rookie has faced at some point. So, this time, I decided that I should make a slight change in my learning process. I decided that I&amp;rsquo;m gonna add some fun and incentive to it, that&amp;rsquo;s why I choose to pursue one of my childhod dreams: cracking softwares.</description><content type="html"><![CDATA[<p>I&rsquo;ve been wanting to dive in the reverse engineering field for a long time. But, everytime I start learning it I get frustrated and stop. I think this is a feeling that every rookie has faced at some point. So, this time, I decided that I should make a slight change in my learning process. I decided that I&rsquo;m gonna add some fun and incentive to it, that&rsquo;s why I choose to pursue one of my childhod dreams: cracking softwares. And I decided that I should start solving keygenmes.</p>
<p>To be honest this wasn&rsquo;t the first one to try out, I solved some easy ones before (too easy to even consider) and I struggled with harder ones. But, this one is the first that presented a challenge for me which ended by solving it and writing a keygen.</p>
<h2 id="initial-reconnaissance">Initial Reconnaissance</h2>
<p>Let&rsquo;s start first by running file command on the executable to collect some initial info. We can see that it&rsquo;s a 32-bit PE executable (which is predictable considering the exe extension)

    <img src="file.png"  alt="file being executed on the executable"  class="center"  style="border-radius: 8px;"  />

</p>
<p>Importing it to PEStudio, we notice it&rsquo;s written in either C or C++ since its PE signature is Microsoft Visual C++. So, our next step would be to decompile it with Ghidra.</p>

    <img src="pestudio.png"  alt="PEStudion analysing the executable"  class="center"  style="border-radius: 8px;"  />


<h2 id="static-analysis">Static analysis</h2>
<p>After importing the executable and opening Ghidra&rsquo;s Code Browser, I take a look at the recovered functions. We could see a bunch of weirdly named functions, among which stands out the entry function, which represents Ghidra&rsquo;s attempt at decompiling the executable&rsquo;s entrypoint.  Double-clicking on it, We get a disassembly of the function along with this seemingly scary source code. That&rsquo;s ghidra&rsquo;s attempt at predicting the executable&rsquo;s source code that resulted in the associated machine code.</p>

    <img src="entry.png"  alt="Entrypoint of our executable"  class="center"  style="border-radius: 8px;"  />


<p>An important point to consider is that the entrypoint of a C or C++ binary isn&rsquo;t the main function, but a sequence of initialization routines called before the execution of the user&rsquo;s code. Of course, our first goal is to recover the main function, which could be done in various ways.</p>
<h3 id="finding-the-main-function">Finding the main function</h3>
<h4 id="an-intuitive-approach">An intuitive approach</h4>
<p>To find the main function, what we could do is run the executable and take a note of the printed strings:</p>

    <img src="execution.png"  alt="Execution of the program"  class="center"  style="border-radius: 8px;"  />


<p>Then using Ghidra&rsquo;s defined strings window, we could search for these strings:</p>

    <img src="definedStrings.png"  alt="Executable&#39;s Defined String"  class="center"  style="border-radius: 8px;"  />


<p>And looking at the references to those strings, this could lead us to the main function, which in our case is FUN_00401630 :</p>

    <img src="mainFunction.png"  alt="Program&#39;s main function"  class="center"  style="border-radius: 8px;"  />


<h4 id="a-methodological-approach">A methodological approach</h4>
<p>Another way to find the main function is to look for the __p___argc() and __p___argv() function calls, whose purpose is to return the argc and argv before passing them to the main function when called.</p>

    <img src="mainFunctionCalledDecompiled.png"  alt="Decompilation of the section where the main function is called"  class="center"  style="border-radius: 8px;"  />


<p>We can see the aforementionned functions&rsquo; return values pushed the stack. So, the next function call is going to be the main function.</p>

    <img src="mainFunctionCalledAssembly.png"  alt="Disassembly of the section where the main function is called"  class="center"  style="border-radius: 8px;"  />


<h3 id="main-functions-analysis">main function&rsquo;s analysis</h3>
<p>At the beginning, we notice this bunch of somewhat look-alike function calls. Seeing they have cin_exref, cout_xref and the printed string literals as arguments. It would be safe to guess that they are just printing the prompts and scanning our input. This could be better affirmed seeing that ghidra identified the use of operator&raquo;.</p>

    <img src="firstPart.png"  alt="First part of the main function"  class="center"  style="border-radius: 8px;"  />


<p>And then comes this big mess.</p>

    <img src="mess.png"  alt="Inlined function"  class="center"  style="border-radius: 8px;"  />


<p>To be honest, I first I doubted that it&rsquo;s just an inlined standard library&rsquo;s function. But, I decided that I should analyze it anyways to make sure I&rsquo;m not missing anything. Two days and a lot of frustration later, I just concluded that it is indeed an inlined function that isn&rsquo;t useful in our context. And this was confirmed later by dynamically analysing the program.<br>
So, I moved on to the rest of the code, And things started making sense. We could see the &ldquo;win&rdquo; conditional branch, an if condition that prints correct to the console if its condition is fulfilled.</p>

    <img src="winBranch.png"  alt="Win branch"  class="center"  style="border-radius: 8px;"  />


<p>What we have to do now is to find when is that condition fulfilled. First, let&rsquo;s simplify it to <code> _DAT_0040543c == DAT_00405440 * 0xe5b0</code>. We could remember that _DAT_0040543c was used before in the call to operator&raquo;. So, we could assume it is one of our inputs. By dynamically analysing the program, I noticed that it holds the Serial value. Now, we have to check where DAT_00405440 comes from.<br>
Looking at the instruction that is right before, we could see that DAT_00405440 is being assigned the result of a certain function. The function is being passed _dst as a parameter, which is being assigned a value in that messy bunch of code we discussed earlier. To make it simple, _dst holds our name input, which is confirmed as usual by dynamic analysis.<br>
Having identified all of our variables, let&rsquo;s have a look at FUN_00401230. Knowing that it is returning the value compared later, let&rsquo;s first have a look at its return instruction.</p>

    <img src="processingFunctionReturn.png"  alt="The return value of the processing function"  class="center"  style="border-radius: 8px;"  />


<p>So, our function is returning uVar4 with some mathematical operations applied. We&rsquo;re gonna jump straight to the block where uVar4 is being assigned a value. We&rsquo;re ignoring all of the preceding code as it&rsquo;s just there to distarct us.</p>

    <img src="processingFunctionCode.png"  alt="The relevant section of the processing function"  class="center"  style="border-radius: 8px;"  />


<p>So, let&rsquo;s start understanding what this do while loop does. Through dynamic analysis, I concluded that _in_stack_00000014 is our name input&rsquo;s length and that the <code>if(0xf&lt; \_in\_stack\_00000018)</code> branch is irrelevant to us. With that out of the way, let&rsquo;s look at the rest of the instructions. We know that param_1 got passed _dst, which is our name input. So, ppuVar3 is a pointer to our name input. uVar6, being initialized to 0 before the loop, is incremented by 1 at each iteration. So, it&rsquo;s simply a counter. pcVar1 contains the uVar6&rsquo;th character of our name input. uVar5 is nothing but an auxiliary buffer holding last iteration&rsquo;s uVar4 value. Having understood all of this, we could finally conclude what&rsquo;s uVa4 holding. But, let&rsquo;s jut clear a little confusing bit before. In C, the char type is simply a 1-byte numerical type. So, when we apply mathematical operations on a char, it is treated as a number. Back at uVar4, at each iteration, it&rsquo;s being assigned the sum of uVar5 and pcVar1 values. That means that at the end of the loop, uVar4 will contain the sum of the ASCII representation of each character in our name&rsquo;s input.</p>
<p>We&rsquo;re nearly finished. At this level, we know that the value stored in _DAT_0040543c should be <code> ((uVar4 ^ 6) * 0x498 ^ 7) * 0xe5b0)</code>. But, there&rsquo;s one little detail that we should pay attention to. To be honest, I&rsquo;ve remarked it during the dynamic analysis and I don&rsquo;t know how to identify it from the disassembly : _DAT_0040543c is a signed int. That means that our input (which is positive) couldn&rsquo;t be bigger than 0x7fffffff (Since the MSB is a sign bit). So, we need a way to bypass this restriction as some names result in a serial bigger than that value. The solution is easy. In C++, negative values are stored using the two&rsquo;s complement. So here&rsquo;s what are we gonna do : If our serial is less than 0x7fffff, we&rsquo;re good. If not, we&rsquo;ll insert the negative of the two&rsquo;s complement of our serial. That way, the stored value will be our serial. This works obviously because - -x = x.</p>
<p>We&rsquo;re done, now we know how the serial is calculated, all we have to do is write a keygen. Since this is a simple algorithm, I&rsquo;ve opted to writing the keygen in python :</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span><span style="color:#999;font-style:italic">#!/usr/bin/env python3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>name = <span style="color:#24909d">input</span>(<span style="color:#ed9d13">&#39;name: &#39;</span>)
</span></span><span style="display:flex;"><span>serial = <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">for</span> char <span style="color:#6ab825;font-weight:bold">in</span> name:
</span></span><span style="display:flex;"><span>        serial += <span style="color:#24909d">ord</span>(char)
</span></span><span style="display:flex;"><span>serial = (((serial^<span style="color:#3677a9">6</span>) * <span style="color:#3677a9">0x498</span> ^ <span style="color:#3677a9">7</span>) * <span style="color:#3677a9">0xe5b0</span>) &amp; <span style="color:#3677a9">0xffffffff</span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">if</span> serial &gt; <span style="color:#3677a9">0x7fffffff</span>:
</span></span><span style="display:flex;"><span>    serial = - ((~serial+<span style="color:#3677a9">1</span>) &amp; <span style="color:#3677a9">0xffffffff</span>)
</span></span><span style="display:flex;"><span><span style="color:#24909d">print</span>(<span style="color:#ed9d13">&#34;Your serial is:  &#34;</span>, serial)
</span></span></code></pre></div><p>If you&rsquo;ve got any question, don&rsquo;t hesitate to contact me.</p>
<hr>
<h4 id="remarks">Remarks:</h4>
<ul>
<li>You can find the keygenme here : <a href="https://crackmes.one/crackme/614b55d433c5d458fcb36575">https://crackmes.one/crackme/614b55d433c5d458fcb36575</a></li>
<li>For the sake of simplicity, I didn&rsquo;t discuss the dynamic analysis process.</li>
</ul>
]]></content></item><item><title>Memory Forensics: A Fun Hands on Introduction</title><link>https://haroun.me/posts/memory-forensics-a-fun-hands-on-introduction/</link><pubDate>Sun, 20 Mar 2022 20:30:00 +0100</pubDate><guid>https://haroun.me/posts/memory-forensics-a-fun-hands-on-introduction/</guid><description>Last weekend, CyberTrace held its first large-scaled event, the Cyber Summit. It held a multitude of conferences and workshops alongside an on-site CTF at night. And I had the honor to be one of the trainers that animated one of the aforementioned workshops. So, as many attendees asked me to, I&amp;rsquo;m writing this walkthrough to collect and preserve the knowledge shared through the workshop. Plus, I&amp;rsquo;m hoping this becomes something of use for people wanting to dive in the forensics field as I didn&amp;rsquo;t find as many well-maintained ressources as i wished while preparing it.</description><content type="html"><![CDATA[<p>Last weekend, <strong>CyberTrace</strong> held its first large-scaled event, the Cyber Summit. It held a multitude of conferences and workshops alongside an on-site CTF at night. And I had the honor to be one of the trainers that animated one of the aforementioned workshops. So, as many attendees asked me to, I&rsquo;m writing this walkthrough to collect and preserve the knowledge shared through the workshop. Plus, I&rsquo;m hoping this becomes something of use for people wanting to dive in the forensics field as I didn&rsquo;t find as many well-maintained ressources as i wished while
preparing it.</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*n3sEc6aukj0e0Z93t_stGQ.png" alt="CyberTrace"></p>
<p>The workshop&rsquo;s topic was memory forensics, and the concerned audience was total beginners that had no clue what does forensics even mean. Considering the short allocated time, which is 2 hours, I chose to challenge myself preparing some quitely dense content and trying to deliver it efficiently. My goal was to introduce the audience to the field without being too superficial. Plus, I was really tired of the classiscal method that the majority of forensics introductions would approach, that is just loosely defining the field and then bombing the audience with volatility&rsquo;s plugins and what they do. So, considering all these factors, I decided that my workshop should be nothing like that and follow a kind of exotic approach.</p>
<h3 id="workshops-scenario-andtools">Workshop&rsquo;s scenario and tools:</h3>
<p>I made the workshop as to be a real life simulation that goes like this:<br>
A non-IT friend of yours notices some weird behaviour on his computer. Random files would appear and disappear, sudden screen blackouts, indicator leds going on and off. So, he reachs out to you, the Cybersecurity saviour, to diagnose his problem. We instruct him on how to take a memory dump of his computer and send it to us, and the rest of the procedure is what we&rsquo;re gonna do during the workshop.</p>
<p>Before we start, let&rsquo;s talk a little about the tools we&rsquo;re gonna need. In fact, it&rsquo;s only one tool called Volatility. It could be considered as the de-facto framework for memory analysis. It&rsquo;s a modular open source tool that contains a multitude of plugins, each one analyzes certainaspects of a dump and provides an output that helps the analyst create an outlook on what is happening. Volatility has two major versions, 2 and 3. Volatility 2 is the well developed older release written in python2. Volatility 3 is the new player in the scene, a complete rewrite of its predecessor written in python3. Although a little underdeveloped as it is somewhat new, it&rsquo;s faster than it&rsquo;s big brother, and we&rsquo;re gonna rely on it throughout the workshop.</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*KfO3uxglMpLOYcyFJ4iDiA.png" alt="Volatility&amp;rsquo;s logo"></p>
<h3 id="enough-talking-lets-get-our-handsdirty">Enough talking, let&rsquo;s get our hands dirty:</h3>
<p>First thing we must do is to try and get some initial info on the machine, this could be done using <em>windows.info</em> (We already know our friend uses windows). This plugin contain some intuitive but necessary info such as the OS version, architecture type and the system time when the dump was made.</p>

    <img src="info.png"  alt="windows.info"  class="center"  style="border-radius: 8px;"  />


<p>We could see that our friend has windows 10. Starting with volatility 3 was a good decision, because if we were to run volatility 2&rsquo;s <em>imageinfo</em> on a windows 10 dump, it would have taken an eternity.</p>
<p>Having a black box dump, a nice starting point would be checking what processes were runnig on the computer, this could be done using <em>windows.pslist</em> plugin (For now, as sometimes a more thorough scan would be needed using <em>windows.psscan</em>).</p>
<p>What i truly advise when using volatility is to save the output of each plugin in a file as it&rsquo;s sometimes very long and verbose which could be hard to manipulate on the terminal.<br>
We&rsquo;re gonna need the output of <em>windows.pslist</em> throughout the whole workshop, but for now, let&rsquo;s analyze it and check for interesting
processes.</p>
<pre tabindex="0"><code>python3 vol.py -f ./workshopMemoryDump.raw windows.pslist | tee ./Workshop/pslist
</code></pre>
    <img src="pslistChrome.png"  alt="chrome.exe in windows.pslist&#39;s output"  class="center"  style="border-radius: 8px;"  />


<p>We could notice <strong>chrome.exe</strong> running, which is pretty interesting knowing that we could extract its history searching for some leads. The problem is that, as we stated above, volatility 3 is still in its early days and lacking many plugins, namely the volatility 2&rsquo;s community plugin <em>chromehistory</em>. We could of course extract history the hard way (By dumping chrome&rsquo;s database), but, for the sake of simplicity, I&rsquo;m going to fallback to volatility 2.</p>

    <img src="chromehistory.png"  alt="Volatility2&#39;s chromehistory output"  class="center"  style="border-radius: 8px;"  />


<p>Okay, pretty interesting, from what we&rsquo;ve seen so long, we could try to form an initial image of what our friend was doing. I think he wanted to crack his GTA 5 installation, so he went through torrent sites to find a valid crack. This could be reinforced by remarking the
<strong>qbittorrent.exe</strong> process running.</p>
<p>I think it&rsquo;s time to have a look at what we could recover from our friend&rsquo;s files. This could be done using <em>windows.filescan</em> plugin. An important note worth remembering here is that <em>windows.filescan</em> is not gonna show us a list of all the files that exist on the system, rather it&rsquo;s going to list files recently or currently loaded in memory.</p>
<pre tabindex="0"><code>python3 vol.py -f ./workshopMemoryDump.raw windows.filescan| tee ./Workshop/filescan
</code></pre><p>Since the output of this plugin is really really really long (as it&rsquo;s going to list all of the operating systems files and dlls alongside other entries). We need to look for certain patterns. What I prefer doing is grepping common user directories such as <em>Desktop</em>, <em>Documents</em>
and <em>Downloads</em>.</p>

    <img src="grepDownloads.png"  alt="Grepping User directories in windows.filescan&#39;s output"  class="center"  style="border-radius: 8px;"  />


<p>One remarkable entry in the output is the <strong>GTA V Crack</strong> directory, containing <strong>patch.exe</strong> and <strong>README.txt</strong>. As we all know, READMEs usually contain instructions as to how to use a software, so let&rsquo;s take a look at <strong>README.txt</strong> by dumping it. All we need to do is to execute the <em>windows.dumpfiles</em> plugin, which is used, as its name states, to dump files from memory. An important fact about dealing with files in relation to memory is that finding them in <em>windows.filescan</em> doesn&rsquo;t necessarily mean it&rsquo;s always possible to dump them. This is a consequence to the volatility of the memory, knowing that a file has existed at a certain time in the memory doesn&rsquo;t mean is still does exist. In other words, not all files that shows up in the output of <em>windows.filescan</em> could be dumped.</p>

    <img src="dumpfiles.png"  alt="Trying to dump README.txt through windows.dumpfiles"  class="center"  style="border-radius: 8px;"  />


<p>We could see that <strong>README.txt</strong> couldn&rsquo;t be dumped, and this is something I struggled with when preparing the lab, due to the very small size of the text file. But, we musn&rsquo;t get desperate, because there&rsquo;s a solution. The NTFS filesystem, used in windows since 1993 uses a data structure known as the Master File Table to index all its files. Each record in the MFT includes some metadata about the file and a pointer to its location on the disk, <em>usually</em>. This is not the case for very small files, which NTFS stores alongside their metadata in their MFT records, such files are called <em>resident files</em>. Here, Volatility3 prematurity arises again, as it only contains <em>winows.mftscan</em>, which is aged a mere 2 months and is incapable of extracting info from the MFT, so we&rsquo;re going to use volatility 2&rsquo;s <em>mftparser</em>.</p>
<pre tabindex="0"><code>python2 vol.py -f ./workshopMemoryDump.raw mftparser | tee ./Workshop/mftparser
</code></pre>
    <img src="readmemft.png"  alt="README.txt MFT record"  class="center"  style="border-radius: 8px;"  />


<p>And as we predicted, <strong>README.txt</strong>&rsquo;s data is there in its MFT record, and it is instructing the user to run <strong>patch.exe</strong>. Going back to <em>windows.pslist</em>&rsquo;s output, we could see that <strong>patch.exe</strong> is in fact running.</p>

    <img src="patch.png"  alt="patch.exe in windows.pslist"  class="center"  style="border-radius: 8px;"  />


<p>So, let&rsquo;s take a little pause to recapitulate our findings. What we found out to this point is this: Our friend, whose computer had weird behaviour, was searching for a crack for GTA 5 on torrent sites. He apparently downloaded a certain torrent and ran the shady executable it contains, as he was instructed by the README. I think that the culprit is becoming crystal clear, <strong>patch.exe</strong> probably contains a malware. But, let&rsquo;s not rush into a conclusion this fast. In fact, as of this point, many analysis possibilities show up. But, I&rsquo;m going to choose an easy path, for the sake of simplicity. Knowing that the weird behaviour on our friend&rsquo;s computer doesn&rsquo;t have a clear pattern, we could safely assume that if a malware exists, it&rsquo;s controlled by an attacker. That means that it needs to connect to a remote address. So, let&rsquo;s check remote connections made by processes using *windows.netstat *.</p>
<pre tabindex="0"><code>python3 vol.py -f ./workshopMemoryDump.raw windows.netstat| tee ./Workshop/netstat
</code></pre>
    <img src="patchNetstat.png"  alt="patch.exe connecting to the remote port 4444"  class="center"  style="border-radius: 8px;"  />


<p>As we predicted, <strong>patch.exe</strong> is connecting to a remote address. The remarkable thing about this connection is the remote port which is <strong>4444</strong>. For those who don&rsquo;t know, <strong>4444</strong> is the default listening port for <em>Metasploit&rsquo;s Meterpreter</em>. So it&rsquo;s somewhat safe to assume by a high probability that the computer is controlled by a <em>meterpreter</em>. But a remote port alone isn&rsquo;t enough to strictly confirm. That&rsquo;s why we&rsquo;re continuing our analysis by executing <em>windows.malfind</em>, which tries to locate malicious code instructions and dlls inside the memory. For the sake of simplicity, here&rsquo;s what I&rsquo;m going to do: I&rsquo;m going to run <em>windows.malfind</em> with the &mdash; dump flag which dumps the suspicious memory areas and then pass it through <em>clamav</em> to test it.</p>
<pre tabindex="0"><code>python3 vol.py -f ./workshopMemoryDump.raw windows.malfind | tee ./Workshop/malfind
</code></pre>
    <img src="clamscan.png"  alt="clamscan result"  class="center"  style="border-radius: 8px;"  />


<p>As we could see, our suspicion turned out to be true, a <em>meterpreter</em> was detected by <em>clamav</em>.</p>
<h2 id="conclusion">Conclusion:</h2>
<p>To conclude our analysis , let&rsquo;s have a little summary of our findings. Our friend, who have a weirdly-behaving computer, searched for a GTA 5 crack and installed a sketchy executable through some torrent then ran it. This executable contained a <em>meterepreter</em> which infected the computer and allowed the attacker to control it and execute whatever malicious command he wished to.</p>
<p><strong>Coming to this conclusion, I mark the end of this workshop. I hope you find it useful, and I hope that it&rsquo;s clear enough for you to understand as I tried to engage in some pretty advanced concepts without losing the beginner-friendly aspect. I&rsquo;d be so happy hearing your feedback, remarks or criticism. So, don&rsquo;t hesitate to contact me.</strong></p>
<hr>
<h3 id="remarks">Remarks:</h3>
<ul>
<li>For reference, here&rsquo;s how a volatility command usually looks like:</li>
</ul>
<pre tabindex="0"><code>python vol.py -f &lt; Memory dump&#39;s path &gt; &lt; plugin name &gt; &lt; plugin arguments&gt;
</code></pre><ul>
<li>Why a Windows 10 dump ? Because I&rsquo;ve had enough of Windows 7 tutorials. Yeah it&rsquo;s more convenient to use but it&rsquo;s way too outdated. People don&rsquo;t use it anymore. So, they can&rsquo;t relate to it. Why Volatility3 ? for the same reason, enough of volatility2. Volatility3 is faster, more compatible with Windows 10, and is starting to catch on Volatility2. Plus, if anyone wants to learn Volatility2 and Windows7 , the internet is full of such tutorials, they won&rsquo;t need to attend a workshop and waste their time.</li>
<li>You could notice that the workshop&rsquo;s flow was kind of linear. That&rsquo;s was made on purpose to keep the attendee&rsquo;s attention. But beware, real life isn&rsquo;t even nearly like this. That&rsquo;s why you should always be cautious not to fall in a rabbit hole.</li>
<li>I advise you to reproduce the steps stated above on your own to better grasp the discussed concepts.</li>
<li>Bonus tips: you could dump a process&rsquo;s memory space using windows.memmap, or its binary using windows.dumpfiles.</li>
</ul>
<hr>
<h3 id="ressources">Ressources:</h3>
<ul>
<li><a href="https://mega.nz/file/AvYHHbqa#tfPm4ZhkS7IUqat7ab__9SKVRtw96BB6Q2R6JqCwm2Q">The memory dump used.</a></li>
<li><a href="https://github.com/volatilityfoundation/volatility3">Volatility 3&rsquo;s repo.</a></li>
<li><a href="https://github.com/volatilityfoundation/volatility">Volatility 2&rsquo;s repo.</a></li>
</ul>
]]></content></item><item><title>Blockchain: An Easy to Digest Detailed Explanation</title><link>https://haroun.me/posts/blockchain-an-easy-to-digest-detailed-explanation/</link><pubDate>Sun, 20 Jun 2021 17:00:00 +0100</pubDate><guid>https://haroun.me/posts/blockchain-an-easy-to-digest-detailed-explanation/</guid><description>Who didn&amp;rsquo;t hear about Bitcoin and the fascinating surge that occured to its value ? And who didn&amp;rsquo;t encounter a post or an article talking about the magic of cryptocurrencies that could make you rich suddenly ? I imagine that everybody could relate to these questions. Unfortunately, this trend and hype is usually used by medias and blogs in order to gain views and reach, but rarely to discuss the technologies behind it.</description><content type="html"><![CDATA[<p>Who didn&rsquo;t hear about Bitcoin and the fascinating surge that occured to its value ? And who didn&rsquo;t encounter a post or an article talking about the magic of cryptocurrencies that could make you rich suddenly ? I imagine that everybody could relate to these questions. Unfortunately, this trend and hype is usually used by medias and blogs in order to gain views and reach, but rarely to discuss the technologies behind it. So today, I decided to talk to you about Blockchain (the underlying architecture of Bitcoin), its fundementals and how it revolutionized the currency market.</p>
<p>First of all, I think it&rsquo;s necessary to clarify some misconceptions. Blockchain isn&rsquo;t Bitcoin, and Bitcoin isn&rsquo;t Blockchain. In fact, it&rsquo;s true that Blockchain was created by <em>Satoshi Nakamoto</em> for the sole prurpose of inventing the Bitcoin. But, it could be used in way more applications other than cryptocurrencies. So, to make it clear since the beginning, I&rsquo;m going to talk about the Blockchain as a data structure and a network, in its broad definition, and not about its usage in cryptocurrencies. And I might be a little biased to the original Bitcoin Blockchain . Although, I am going to cover other variations in another post.</p>
<p><strong>So, to begin with, let&rsquo;s talk about what blockchain is ? and what are its main components ?</strong></p>
<p>Blockchain is a <em>decentralised, distributed</em> and usually public data structure and network. Its main goal is to be a <em>trustworthy ledger</em>, or generally speaking, a <em>trustworthy archive of information</em>, without needing a central authority to ensure this trust.</p>
<p>A Blockchain is formed of blocks. Each block is no more than a set of data that is structured according to strict rules, and is built on top of a previous block, starting from the initial <em>Genesis Block</em>. A block&rsquo;s header contains necessarily a <em>Merkle root</em>, the previous block&rsquo;s hash (except for the initial one of course) and a <em>nonce</em> in some cases (that we&rsquo;ll discuss later). A blocks&rsquo;s body contains the <em>Merkle Tree</em> associated with the forementioned <em>Merkle Root</em>. Before passing to the next question, let&rsquo;s first discuss what a <em>Merkle Tree</em> is.</p>
<p>To put it in simple terms, a <em>Merkle tree</em> is a full binary tree of hashes. <em>Merkle tree</em>&rsquo;s leaves are transactions/data included in the block. Each parent in the tree is a hash of his two siblings. So, if a single transaction is changed, even slightly, the <em>Merkle Root</em> will change drastically. This is useful when checking for the integrity of a block.</p>
<p><strong>So, now we know what a blockchain is, and how it is formed. But, who is responsible for creating and verifying the blockchain ?</strong><br>
In fact, the answer to this question is as famous as Bitcoin. The creation and verification of a Blockchain is the miners&rsquo; job. To better illustrate a miner&rsquo;s work, let&rsquo;s talk about the general process of block creation. First, a transaction/data is issued and broadcasted to the network. It will be then included in a transaction/data pool. Then, a miner will grab a bunch of transactions/data according to some criteria to form a new block. He creates the <em>Merkle Tree</em> out of those transactions/pieces of data and includes it in the block. He calculates he nonce if there is any. And when all of this is ready, he adds the block to the blockchain by appending the previous block&rsquo;s hash in the present hash&rsquo;s header.</p>
<p><strong>But, what if two miners submit their blocks at the same time ?</strong></p>
<p>Well, don&rsquo;t worry, blockchain is built ready for this problem. Both blocks will be accepted, but one of them will be later dismissed. In fact, a strict rule in blockchain is that the longest chain must be the main chain. In other words, when both blocks are added, future blocks will be built on either of these conflicting ones. The block on which a longer chain is built will be kept, while the other block and the chain that followed him will be deprecated and orphaned, their transactions/data will be sent back to a transactions/data pool.</p>
<p><strong>Here, a serious question arises, how are we sure that every miner will submit an honest trustworthy block ?</strong></p>
<p>This is where consensus kicks in. What&rsquo;s consensus ? it is any form of rules, procedures or protocols that leads to a major undebatable agreement. One of many ways to reach consensus in blockchains is the <em>Proof-Of-Work</em>. <em>Proof-Of-Work</em> is a cryptographic challenge that proves undoubtedly that a certain party has exerced some amount of work. As usual, to make things simple and clear, let&rsquo;s talk about how <em>Proof-Of-Work</em> is applied in the case of blockchain. Let&rsquo;s go back to block creation. When a block is created for a blockchain that requires <em>PoW</em>, the miner has to find a number called a <em>nonce</em> (mentioned above) that, when added to the block&rsquo;s header, results in a block hash that starts with a given number of zeros. But how does this ensures the honesty of the blockchain ? Okay, let&rsquo;s suppose a malicious miner has decided to append a dishonest block (where he tries to spend a coin he already spent for example). Since the rest of the miners will refuse to build on top of this block, an honest block will be appended on the same height, creating a conflict. To make sure his block will be accepted, the dishonest miner must race the rest of miners and create the longer chain on top of his dishonest block. That means his hashrate must surpass the hashrate of all the other miners combined. Put in simple terms, for a dishonest miner to append a dishonest block, he must own over half of the processing power of the blockchain. This is one way of reaching consensus and building an honest blckchain, but it isn&rsquo;t the only one. We&rsquo;ll discuss other methods in another post.</p>
<p><strong>The image is starting to get clear now. But, we must ask a very important question. Why would a miner bother sacrifice all this power and CPU time with no apparent benefice ?</strong></p>
<p>Well, because there is a benefice. The benefice is called an <em>incentive</em>. It is some kind of a reward that a miner gets when his block becomes a part of the blockchain. It could take many forms. In Bitcoin there is two forms. One way of getting rewarded is that a miner would append a special transaction on his block that states that he received a certain fixed amount of coins. In this way, if his block is appended, he would possess that amount of coins. The other way is by obtaining a tip from users on every transaction performed, called <em>transaction fees</em>. Like this, we would make sure that miners are motivated and satisfied.</p>
<p>This was a little guide on how blockchains work. I hope that you enjoyed your read and that you didn&rsquo;t get bored. Expect another post from me that talks about other variations that are slightly different from the one discussed above. And if you have the slightest comment to add, don&rsquo;t hesitate to contact me.</p>
<hr>
<p><em>References:</em></p>
<ul>
<li><a href="https://bitcoin.org/bitcoin.pdf">Bitcoin&rsquo;s original white paper.</a></li>
<li><a href="https://selfkey.org/what-is-a-merkle-tree-and-how-does-it-affect-blockchain-technology/">What is a Merkle Tree and How Does it Affect Blockchain Technology?</a></li>
<li><a href="https://www.youtube.com/watch?v=bBC-nXj3Ng4">But how does bitcoin actually work?</a></li>
</ul>
]]></content></item></channel></rss>