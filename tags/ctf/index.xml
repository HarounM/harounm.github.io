<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CTF on Haroun Maghraoui</title><link>https://harounm.github.io/tags/ctf/</link><description>Recent content in CTF on Haroun Maghraoui</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Mon, 23 May 2022 12:00:01 +0100</lastBuildDate><atom:link href="https://harounm.github.io/tags/ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>TShains</title><link>https://harounm.github.io/writeups/securinets-cyberleaguectf-2022/tshains/</link><pubDate>Mon, 23 May 2022 12:00:01 +0100</pubDate><guid>https://harounm.github.io/writeups/securinets-cyberleaguectf-2022/tshains/</guid><description>In the challenge, we&amp;rsquo;re given this code :
flag = b64encode(flag) enc = b&amp;#34;&amp;#34; for i in range(len(flag)): enc += bytes([flag[i] ^ flag[(i+1) %len(flag)]]) enc = b64encode(enc) # Z1oYPRg5GS1qfAcHCgIJF2p7e3wKHWloaH4hIQoCMzwaFnho What it&amp;rsquo;s doing is simple. It encoded the flag in base64, XORed its characters two by two, encoded it again then printed it. The important detail that we&amp;rsquo;re gonna exploit is that it XORs the last character with the first one. So, all we have to do is to bruteforce the first character using the base64 alphabet, XORing the rest of the characters and doing the necessary decoding.</description></item><item><title>Vault Keeper</title><link>https://harounm.github.io/writeups/securinets-cyberleaguectf-2022/vaultkeeper/</link><pubDate>Mon, 23 May 2022 12:00:01 +0100</pubDate><guid>https://harounm.github.io/writeups/securinets-cyberleaguectf-2022/vaultkeeper/</guid><description>Challenge Explanation In this challenge, we&amp;rsquo;re given this source code.
from Crypto.Util.number import getPrime, long_to_bytes, inverse, getRandomNBitInteger from secrets import flag class RSA: def __init__(self): self.p = getPrime(512) self.q = getPrime(512) self.e = 0x10001 self.n = self.p * self.q self.d = inverse(self.e, (self.p-1)*(self.q-1)) self.DaVinciSecretPass = b&amp;#34;Gimme The Ultimate Secret&amp;#34; def sign(self, data): return pow(data, self.d, self.n) def verify(self, data, sig): return self.sign(data) == sig def welcome(): welcom = &amp;#34;&amp;#34; welcom += &amp;#34;&amp;#34;&amp;#34; __ __ ______ __ __ __ ______ __ __ ______ ______ ______ ______ /\ \ / / /\ __ \ /\ \/\ \ /\ \ /\__ _\ /\ \/ / /\ ___\ /\ ___\ /\ == \ /\ == \ \ \ \\&amp;#39;/ \ \ __ \ \ \ \_\ \ \ \ \____ \/_/\ \/ \ \ _&amp;#34;-.</description></item><item><title>Davinci Secret Room</title><link>https://harounm.github.io/writeups/securinets-cyberleaguectf-2022/davincisecretroom/</link><pubDate>Mon, 23 May 2022 12:00:00 +0100</pubDate><guid>https://harounm.github.io/writeups/securinets-cyberleaguectf-2022/davincisecretroom/</guid><description>Challenge explanation: In this challenge, we get the source code of the server running at the CTFs infrastructure.
from Crypto.Cipher import AES from Crypto.Util.Padding import pad,unpad from secrets import flag import random import os BLOCK_SIZE = 16 KEY = os.urandom(BLOCK_SIZE) def encrypt(msg): iv = os.urandom(BLOCK_SIZE) cipher = AES.new(KEY, AES.MODE_CBC, iv) return (iv + cipher.encrypt(pad(msg, BLOCK_SIZE))).hex() def decrypt(data): iv = data[:BLOCK_SIZE] cipher = AES.new(KEY, AES.MODE_CBC, iv) return unpad(cipher.decrypt(data[BLOCK_SIZE:]), BLOCK_SIZE) def parse(enc_token): dec = decrypt(enc_token) splitted_token = dec.</description></item></channel></rss>